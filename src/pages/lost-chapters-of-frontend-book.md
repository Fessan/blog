### Архитектура

### Структура

### Семантика

![](lost-chapters-of-frontend-book/semantics-description.png)

Под семантикой в языке подразумевается **смысловое значение**, т.е. наличие семантики - это наличие явности выражения мысли.

Главный слоган семантики - **явное лучше не явного**.

- null VS undefined. В чем проблема этого кода `var obj = { list: undefined }; newObj = copyObj(obj); if(newObj.list !== undefined) newObj.list.push()`?
  > maybe VS optional

  > null - это намеренно пустое значение. undefined - это неожиданно пустое значение, подсказка-хелпер рантайм мира, которой в статически-типизированных ЯП не бывает (там undefined == TypeError). Поэтому никогда не используйте undefined нарочно - это целенаправленное запутывание кода. Например: `var obj = { list: undefined }; newObj = copyObj(obj); if(newObj.list !== undefined) newObj.list.push()` - в чем проблема этого кода? Если в `copyObj` будет ошибка из-за которой `list` удаляется или теряется - мы об этом не узнаем, потому что в данном коде undefined отвечает и за предсказуемое и за непредсказуемое поведение. Если бы в `obj.list` по умолчанию использовался бы null, в проверке `newObj.list !== null` мы бы получили `true` и далее, если в `copyObj` была ошибка и свойство потерялось, то на `list.push()` - код бы упал и ошибку было бы проще найти, чем если бы, при использовании undefined `list.push()` вообще не отработал и ошибки не явным образом уже бы проявились уже в самом приложении.

  > Кто-то может заметить, что проверку можно было бы делать более явную `if(Array.isArray(newObj.list)`, но в этом случае, если бы в `newObj.list` находилось, по ошибке, что-то кроме массива и null (которые ожидаются), то дальнейшую ошибку в работе самого приложения было бы дебажить сложнее. С другой стороны проверка `newObj.list !== null` не дает нам никакого представления о том что находится внутри свойства `list` (оно могло бы и по другому называться), поэтому не использование строгой проверки на массив так же является плохой практикой. Эта проблема решается использованием статической типизации или контрактного программирования.
- JSX VS JS
  > JSX семантически это верстка, он отвечает за то ***что*** будет отображаться, а не ***как***, потому что его задача именно в инкапсуляции логики `document.createElement`. Результат JSX, как и результат самого HTML всегда должен быть статичен, в независимости от данных. В подтверждение этому выступает апи хуков жизненного цикла - оно описывается в JS - это наглядно.

  > Например, `react-router` является примером очень плохого апи, т.к. через компонент `<Switch>` он предлагает описывать логику зависимостей от данных прямо в JSX (более того, сам элемент превращается в управляющий блок) - при этом семантика полностью рушится, что ведет к ментальному усложнению чтения кода - в голове нужно держать больше контекста. Правильнее в JS (в начале блока функционального компонента или метода `render`) описывать все зависимости - высчитывать их и потом в конечный возвращаемый JSX вставлять все необходимое: `title = predicate ? 'first' : 'second'; return <span>{title}</span>` - это и есть декларативное описание.

  > Желание описать роутинг (или что угодно еще, есть даже библиотека с компонентами `<If>`, `<For>`) декларативно - понятно, т.к. это кажется нагляднее и проще (хотя не все так просто, потому что `пониманиеАбстракции = время(документация)`). Но нужно понимать, что декларативное описание не обязано иметь единственный синтаксис \ шаблон. JSX - это декларативный синтаксис к описанию биндинга модели приложения на DOM, но это означает что его не нужно использовать для декларативного описания конструкций, которые не относятся к DOM напрямую. Для написания декларативного кода можно использовать, например, библиотеку [Ramda](https://ramdajs.com), писать [макросы](https://github.com/kentcdodds/babel-plugin-macros) и много другое.
- Proxy, get, set
  > Proxy, get и set - реализуют паттерн "заместитель", при котором возможно перехватить обращение к свойствам целевого объекта для выполнения какой-то дополнительной логики. Проблема этого паттерна в том что он воздействует на поведение программы, но это [воздействие] никак не отражается визуально для программиста. Т.е. говоря о семантике - в этом паттерне она просто отсутствует. 

  > Если в проекте используются прокси или геттеры и сеттеры, то в любой случайной точке кодовой базы никогда нельзя быть до конца уверенным есть здесь они или нет. Это невидимый контекст, что бы узнать о котором иногда, особенно в больших проектах, требуется исследовать большое количество связанного кода. Таким образом приходится либо постоянно быть не уверенным в читаемом коде, либо производить его многочисленные инспекции. Решением этой проблемы может быть использование паттерна "декоратор", или любое явное использование контекста и зависимостей.

  > P.S. вместо `react-router` я рекомендую использовать что-то вроде `redux-first-router`.

### Прикладные советы

- `export default` только для top-level
  - явная связанность
  - проще поиск
  - проще рефакторить
- `renderProp()`
  - только для функционального DI (если нужно получить аргументы из одного уровня в другой)
  - выносите в отдельные компоненты: меньшая связанность, легче испектировать в реакт-девтулзах
- `this.props`
  - объявляйте все используемые переменные в начале блока кода

#### Обработка ошибок

- Если вы останавливаете прерывание, всегда используйте `setTimeout`.
- Используйте `window.onerror` для логирования.
- Есть несколько классов (типов) `Error`, от них можно наследоваться - создание собственных ошибок потом поможет в их обработке с `instanceof`.
- Модифицируйте `message` - делайте его информативнее, добавляйте название фичи (бизнес-сущности), в которой был осуществлен перехват ошибки.
- Используйте блок `finaly`.

```javascript
class FeatureError extends Error { constructor(message) {

  if (typeof message === 'string') return super(message)

  super('@@FeatureName: error!\nSee error data in `data` property of this Error instance')
  this.data = message

} }

try { throw /* */ } catch (e) {

  const error = e instanceof Error ? e : new OwnError(e)

  setTimeout(() => { throw error })
}
```

#### Devtools

- react-devtools
  - [profiler](https://reactjs.org/blog/2018/09/10/introducing-the-react-profiler.html)
- redux-devtools
  - научите пользоваться снапшотами тестировщиков - это сильно упростит их задачу
- [kuker](https://github.com/krasimir/kuker)
- debugger в IDE - это очень удобно: реальные данные выводяться прямо из переменной
- Шарьте основные элементы приложения в window в дев сборке

#### Автоматические проверки и инструменты

- Статическая проверка типов: flow, TS, ReasonML, ClojureScript, Kotlin, Elm, Dart...
- Контракты, особенно для любого внешнего API (сеть, библиотеки).
- eslint, stylelint, commitlint. Пишите свои плагины.
- Тесты. Освойте pupettier.
- prettier.
- editorconfig.
- ?codmod.
- `TODO:` и `FIXME:` и их подсветка в IDE. Мб линтер на ПР в мастер.

#### Документирование

- README.md
  - общее описание бизнес-цели проекта
  - ссылки на основные ресурсы: git, jira (backlog, sprint, готовые фильтры под это)
  - список сред (дев, стейдж, тест, прод) и прав доступа к ним
  - ссылки на контакты ключевых ответственных лиц в проекте
    - ПМ, техлид (бек и фронт), тимлид (бек и фронт), тестировщик, дизайнер, девопс, сетевик
    - их почты, телефоны, чаты
  - список ссылок для ознакомления с *архитектурой* (например, при использовании Atomix)
- CONTRIBUTING.md
  - инструкция по настройке инфраструктуры, среды
  - общие правила и их выражения в конфигах линтеров
  - gitflow
  - правила ревью кода
- CODE_OF_CONDUCT.md
  - ???
- CHANGELOG.md
  - описание легаси, например, все частично используемое (перешли на новую технологию, но не выпилили старую)
