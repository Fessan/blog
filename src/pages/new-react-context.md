# Новый контекст в React

### Что такое контекст

В React компонентах, помимо `props`, которые могут быть доступны только у первого потомка от родителя, есть доступ к контексту ([Context](https://reactjs.org/docs/context.html)) - который доступен у всех потомков родителя (объявившего контекст). Это означает, что как бы глубоко компонент не находился в дереве компонентов, он имеет доступ к контексту, который мог быть создан на сколь-угодно много ветвлений дерева выше (ближе к корню). При этом если контекст обновляется - это так же вызывает обновление всех [подписанных](https://reactjs.org/docs/context.html#how-to-use-context) (использующих контекст) потомков. На основе этого API работают все популярные библиотеки, которым необходимо иметь доступ к общим данным из любой глубины приложения: react-redux, react-mobx, react-router, styled-components (ThemeProvider).

### Проблемы существующего контекста

Если на определенный контекст подписан и родитель - **componentA** и его непосредственный потомок - **componentB** то при обновлении контекста нужно произвести обновление их обоих. Из-за этого **componentA** обновится 1 раз, а **componentB** два раза: сначала из-за обновления **componentA**, а потом из-за обновления самого контекста (т.к. компонент на него подписан). Соответственно, количество обновлений подписанного компонента === количеству его подписанных родителей + 1 (собственная подписка компонента). Конечно - это не эффективно и трудозатратно, с точки зрения производительности. 

Существуют техники и алгоритмы обхода подписчиков таким образом, что бы минимизировать (или полностью исключить) дублирование обновления глубоко-лежащих подписчиков, но их реализация может быть трудоёмкой. Подробнее об этом [рассказывал](https://youtu.be/TfxfRkNCnmk) автор библиотеки `mobx`. И это является проблемой, потому что разрабатывая какую-либо библиотеку, имеющую глобальное динамическое состояние, автор должен тратить лишние силы и думать об обновлении подписчиков (реализовывать свой механизм "правильного" обхода, поверх механизма контекста), чем, казалось бы, должен заниматься React.

### Новое API `React.createContext`

Многие восприняли новый контекст ([`React.createContext`](https://habrahabr.ru/company/ruvds/blog/348862/)) - как замену `redux` (или любого другого менеджера состояний), но это как сравнивать теплое и мягкое. В действительности основная цель обновления контекста - это взять на себя задачу по эффективному обновлению подписчиков ([подробности](https://twitter.com/dan_abramov/status/976486152197812229) от Дэна Абрамова), что бы авторы библиотек могли сконцентрироваться на целевом функционале разрабатываемого пакета. Так же обновленный контекст предоставляет более удобный интерфейс для его использования.

При этом можно отметить, что `redux` имеет минимальное API для работы с состоянием: подписка и обновление, которое может быть заменено на использование `state` (и `setState`) из обычного `React.Component`. Поэтому правильнее сказать что новый контекст, в каких-то задачах, можно использовать вместо `redux`, подразумевая что вместо него будет использоваться состояние и обновление `React.Component`, а вместо `react-redux` - `React.createContext`.

### P.S.
Если вам не нравится подход `render-prop` и вы хотите использовать "старые добрые" HOC, вот простой пример как это можно сделать с мемоизацией:
```javascript
const connect = selector => target => ({ children, ...props }) => {
  let updateFromParent = true;
  let cachedState = null;
  let cachedComponent = null;
  return (
    <Consumer>
      {value => {
        const state = selector(value, props);
        if (!updateFromParent && (state === cachedState || shallowCompare(state, cachedState))) {
          updateFromParent = false;
          return cachedComponent;
        } else {
          updateFromParent = false;
          cachedState = state;
          return (cachedComponent = React.createElement(target, { ...props, ...state }, children));
        }
      }}
    </Consumer>
  );
};
```