<!-- 
- https://habr.com/p/491948/
 -->

# Что такое UI-toolkit и Reakit в частности

[Reakit](https://reakit.io) - это не просто очередной набор визуальных компонентов, вроде Bootstrup, это базовые логические примитивы для построения UX-, a11y- и DX-дружелюбных компонентов и веб-приложений. Reakit не диктует как должны выглядеть ваши компоненты и поэтому в его сборке совершенно отсутствуют стили, лишь [хуки](https://reactjs.org/docs/hooks-intro.html) для удобного описания логики компонентов.

В разных источниках термины ui-kit / ui-toolkit могут означать несколько разные вещи, имея разные контексты. Чаще всего используется именование ui-kit которое описывает библиотеку визуальных компонентов и, возможно, прикладные принципы брендбука продукта. У кого стояла задача разработать единую библиотеку компонентов под несколько отличающихся продуктов знает, что это очень тяжёлая задача с множеством трейдофов - никогда не получится сделать серебряную пулю и цена универсализации это, чаще всего, плохой DX несущий увеличение сложности и стоимости поддержки.
Но если, все же, хочется получить какую-то универсализацию для экономии ресурсов, как для упрощения старта нового продукта, так и для упрощения переключения разработчиков между продуктами, необходимо выделять определенные, желательно небольшие, системные интерфейсы в обособленные модули и проектировать их с соответствующим расчетом.

Применительно к топику определим что ui-kit - это общий комплекс ресурсов отвечающих за визуальные компоненты системы: макеты, стили, стори, принципы их компоновки и кастомизации. А вот ui-toolkit - это лишь набор функциональных примитивов для описания логики работы компонентов с точки зрения UX. Так вот Reakit - это ui-toolkit

У Reakit нет стилей и функционала для темизации. Нет даже монструозных компонентов с бесконечно раздутыми API, а лишь набор совершенно базовых блоков, перечень хуков описывающих логику и хранящих ее состояние и документация с описанием как их этого всего лучше создавать собственные комплексные компоненты. Иначе говоря Reakit, вместо того что бы давать готовое, но монструозное и ограниченное решение, даёт набор базовых кирпичиков и инструкцию по тому как их лучше собрать, что делает его по настоящему гибким и переиспользуемым.

## Пример

![](http://www.rootzilopochtli.com/wp-content/uploads/2018/02/linus-1024x965.png)

Классический пример компонента [Menu](https://inclusive-components.design/menus-menu-buttons/) выглядит, часто, так:

```ts
import { Menu } from "ui-lib";

function Example() {
  return (
    <Menu
      title="Preferences"
      aria-label="Preferences"
      items={["Settings", "Extensions", "Keyboard shortcuts"]}
    />
  );
}
```

Что делать, если одному из элементов необходимо добавить какие-то дополнительные атрибуты? Например `Extensions` заблокированы для текущего пользователя. Или что делать если есть требование к какой-то нестандартный стилизации определенного элемента или вообще его переопределения? А если нам необходимо добавить разделитель, нужно ли учитывать его индекст для обработчика `onChange` и как вообще передать информацию об изменении (выборе элемента) меню?
Все это решается либо непомерным раздуванием API компонента, которое нужно документировать, тестировать, в общем поддерживать.
Или весь контроль отдается пользователю компонента с помощью рендер-методов, аля `renderItem` (привет redux-form) который позволяет определить функцию принимающую системные свойства от корневого Menu что бы определить и вернуть каждый конкретный элемент. Но, [я считаю](https://youtu.be/rVFW009olAI?t=2034), это является антипатерном т.к. очень сильно усложняет дебаг (из-за того что данные неявно хранятся в замыканиях и по ссылкам курсируют через несколько вызовов функций, что сложно быстро инспектировать) и, часто, убивает мемоизацию провоцируя избыточные рендеры и негативно влияя на производительность (я лично наблюдал это на нескольких проектах).

```ts
import { Menu, Separator } from "ui-lib";

function Example() {
  return (
    <Menu
      title="Preferences"
      aria-label="Preferences"
      items={[
        { id: 1, content: "Settings" },
        { id: 2, content: "Extensions", disabled: true },
        { id: 3, content: () => <Separator /> },
        { id: 4, content: "Keyboard shortcuts" }
      ]}
    />
  );
}
```

Но есть и другой путь - отступить немного назад и описывать все более низкоуровнево. [Вот пример из reakit](https://reakit.io/docs/menu/#usage):

```ts
import { useMenuState, Menu, MenuItem, MenuButton, MenuSeparator } from "reakit/Menu";

function Example() {
  const menu = useMenuState();
  return (
    <>
      <MenuButton {...menu}>Preferences</MenuButton>
      <Menu {...menu} aria-label="Preferences">
        <MenuItem {...menu}>Settings</MenuItem>
        <MenuItem {...menu} disabled>Extensions</MenuItem>
        <MenuSeparator {...menu} />
        <MenuItem {...menu}>Keyboard shortcuts</MenuItem>
      </Menu>
    </>
  );
}
```

Да, кода кажется больше, но это скорее не бойлерплейт (избыточный шаблонный код), а в общем больше символов, но которые позволяют выделять ключевые атрибуты более явно и семантично - код в котором сущности (`MenuButton`, `MenuItem`) представлены не просто свойствами корневого компонента (`Menu`), а полноценными компонентами сразу понятно как модифицировать и вносить любые изменения (просто прокинуть props) - при этом документировать и тестировать такой код намного проще, потому что мы не вносим лишнюю вариативность расширением абстракций собственным API.

## UX и a11y

Помимо описанных выше системных проблем при разработке переиспользуемых и настраиваемых компонентов всегда, встает вопрос качественного UX, который реализовать совсем не просто. Тот же компонент Menu содержит немалый перечень паттернов дружественного поведения, которые не выразить просто нативными средствами браузера. Например: появление списка в относительно большей области вьюпорта, зацикленное перемещение фокуса, обработка клавишь (стрелки, Page Up/Page Down, Home/End), a11y, и это еще без виртуализации и мобильного вида <!-- https://twitter.com/devongovett/status/1248304777588441088 -->. Reakit больше всего заботится и предоставляет функциональность этих лучших UX практик из коробки! Как [говорит сам автор](https://twitter.com/diegohaz/status/1232325270733979648), с Reakit вы даже не замечаете как делаете ваши компоненты лучше и полноценнее.

Основный посыл данной статьи именно в том что бы показать ui-toolkit который может не навязывать свой дизайн и ограничивать функциональность компонентов своим API, а предоставлять всю необходимую функциональность для простой реализации лучших практик пользовательского опыта. Хотелось бы что бы таких решений на рынке (OSS) было бы больше. Пока что я не встречал альтернатив Reakit: есть [rebass](https://rebassjs.org), но он не до конца расскрывает тему, как мне кажется. Есть еще [reach-ui](https://reacttraining.com/reach-ui), который ближе к описанной идее, но все еще, хоть и немного, навязывает API шаблонов и стилизации

## DX

Из описанных выше примеров видно, что помимо семантичных компонентов Reakit предоставляет набор хуков, которые содержат в себе и контролируют состояние компонента и логику его работы. Это очень правильный и гибкий подход - разделение логики и интерфейса (в смысле параметров) представления - компонентов. Хуки можно импортировать отельно от компонентов - они прекрасно тришейкаются, и композировать как угодно в своих нуждах, добавляя или корректируя функционал. В то время как компоненты описывают и частично [валидируют](https://reakit.io/docs/accessibility/#accessibility-warnings) основные параметры, которые необходимы для их правильной реализации. Их, конечно, тоже можно использовать отдельно.

Почему такое разделение на компоненты и хуки - самый удачный вариант описания API, автор Reakit подробно описывает [тут](https://twitter.com/diegohaz/status/1229499924062048260). Вкратце, как уже было сказано, дело в возможностях композиции, модификации и переиспользования. Это описано и в документации [тут](https://reakit.io/docs/basic-concepts/) и [тут](https://reakit.io/docs/composition/).

Еще один плюс Reakit, как низкоуровнего ui-toolkit - это полное отсутствие стилей из коробки. Проблема многих ui-kit в том что их стили завязаны на бандлер и при их сильной стилевой модификации изначальные стили, часто, сложно вырезать из бандла и все равно приходится их тащить на клиент. У Reakit есть [отдельный пакет](https://github.com/reakit/reakit/tree/next/packages/reakit-system-bootstrap) со стилями похожий на bootstrap, но он именно отдельный. Reakit, за счет своей полной атомарности, прекрасно стилизуется в любых мелочах, т.к. все сложные компоненты композируются из простых доступ к которым есть изначально.

Зато, все отлично тришейкается и в целом каждый компонент имеет небольшой вес. Так же есть [бандл под CDN](https://reakit.io/docs/get-started/#cdn)
[![](КАРТИНКА)](https://bundlephobia.com/result?p=reakit).

У меня был опыт использования Reakit с reshadow - очень понравилось: хороший DX с семантичным описанием стилей и очень производительный код на выхлопе. Выглядит [как-то так](https://t.me/react_js/770117):

(в IDE подсветка и автодополнение CSS-кода работает)

```jsx
export function Example() {
  const menu = useMenuState();
  return styled`
    MenuItem:hover {
      cursor: pointer;
    }
    MenuItem[disabled] {
      pointer-events: none;
    }
  `(
    <>
      <MenuButton {...menu}>Preferences</MenuButton>
      <Menu {...menu} aria-label="Preferences">
        <MenuItem {...menu}>Settings</MenuItem>
        <MenuItem {...menu} disabled>
          Extensions
        </MenuItem>
        <MenuSeparator {...menu} />
        <MenuItem {...menu}>Keyboard shortcuts</MenuItem>
      </Menu>
    </>
  );
}
```

Я бы рекомендовал брать Reakit за основу своего ui-kit каждый раз, когда для продукта предполагается собственный дизайн.

В общем Reakit очень интересная и уже достаточно стабильная библиотека, автор около года занимается ей фултайм, на гитхабе видно что у нее уже [более полусотни](https://github.com/reakit/reakit/graphs/contributors) участников внесли свой вклад и пару недель назад вышла release condidate версия.

Напоследок обращу внимание на то что все примеры компонентов в документации интерактивные и редактируемые - попробуйте сами добавить несколько элементов к `Menu` и поиграться со стейтом - https://reakit.io/docs/menu/#submenu.

Дополнительно о Reakit можно еще почитать тут:
- https://rangle.io/blog/accessibility-360-web-and-mobile/
- https://survivejs.com/blog/reakit-interview/
