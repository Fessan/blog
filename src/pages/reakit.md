<!-- 
- https://habr.com/p/491948/
 -->

# Что такое UI-toolkit и Reakit в частности

[Reakit](https://reakit.io) - это не просто очередной набор визуальных компонентов, вроде Bootstrup, это базовые логические примитивы для построения UX-, a11y- и DX-дружелюбных компонентов и веб-приложений. Reakit не диктует как должны выглядеть ваши компоненты и поэтому в его сборке совершенно отсутствуют стили, лишь [хуки](https://reactjs.org/docs/hooks-intro.html) для удобного описания логики компонентов.

В разных источниках термины ui-kit / ui-toolkit могут означать несколько разные вещи, имея разные контексты. Чаще всего используется именование ui-kit которое описывает библиотеку визуальных компонентов и, возможно, прикладные принципы брендбука продукта. У кого стояла задача разработать единую библиотеку компонентов под несколько отличающихся продуктов знает, что это очень тяжёлая задача с множеством трейдофов - никогда не получится сделать серебряную пулю и цена универсализации это, чаще всего, плохой DX несущий увеличение сложности и стоимости поддержки.
Но если, все же, хочется получить какую-то универсализацию для экономии ресурсов, как для упрощения старта нового продукта, так и для упрощения переключения разработчиков между продуктами, необходимо выделять определенные, желательно небольшие, системные интерфейсы в обособленные модули и проектировать их с соответствующим расчетом.

Применительно к топику определим что ui-kit - это общий комплекс ресурсов отвечающих за визуальные компоненты системы: макеты, стили, стори, принципы их компоновки и кастомизации. А вот ui-toolkit - это лишь набор функциональных примитивов для описания логики работы компонентов с точки зрения UX.

У Reakit нет стилей и функционала для темизации. Нет даже монструозных компонентов с бесконечно раздутыми API, а лишь набор совершенно базовых блоков, перечень хуков описывающих логику и хранящих ее состояние и документация с описанием как их этого всего лучше создавать с собственные комплексные компоненты. Иначе говоря Reakit, вместо того что бы давать готовое, но монструозное и ограниченное решение, даёт набор базовых кирпичиков и инструкцию по тому как их лучше собрать, что делает его по настоящему гибким и переиспользуемым.

## Пример

![](http://www.rootzilopochtli.com/wp-content/uploads/2018/02/linus-1024x965.png)

Классический пример компонента [Menu](https://inclusive-components.design/menus-menu-buttons/) выглядит, часто, так:

```ts
import { Menu } from "ui-lib";

function Example() {
  return (
    <Menu
      title="Preferences"
      items={["Settings", "Extensions", "Keyboard shortcuts"]}
    />
  );
}
```

Что делать, если одному из элементов необходимо добавить какие-то дополнительные атрибуты? Например `Extensions` заблокированы для текущего пользователя. Или что делать если есть требование к какой-то нестандартный стилизации определенного элемента или вообще его переопределения? А если нам необходимо добавить разделитель, нужно ли учитывать его индекст для обработчика `onChange` и как вообще передать информацию об изменении (выборе элемента) меню?
Все это решается либо непомерным раздуванием API компонента, которое нужно документировать, тестировать, в общем поддерживать. Или весь контроль отдается пользователю компонента с помощью рендер-методов, аля `renderItem` который позволяет определить функцию принимающую системные свойства от корневого Menu что бы определить и вернуть каждый конкретный элемент. Но, [я считаю](https://youtu.be/rVFW009olAI?t=2034), это является антипатерном т.к. очень сильно усложняет дебаг (из-за того что данные неявно хранятся в замыканиях и по ссылкам курсируют через несколько вызовов функций, что сложно быстро инспектировать) и, часто, убивает мемоизацию провоцируя избыточные рендеры и негативно влияя на производительность (я лично наблюдал это на нескольких проектах).

Но есть и другой путь - отступить немного назад и описываться все максимально верхнеуровнево. [Вот пример из reakit](https://reakit.io/docs/menu/#usage):

```ts
import {
  useMenuState,
  Menu,
  MenuItem,
  MenuButton,
  MenuSeparator
} from "reakit/Menu";

function Example() {
  const menu = useMenuState();
  return (
    <>
      <MenuButton {...menu}>Preferences</MenuButton>
      <Menu {...menu} aria-label="Preferences">
        <MenuItem {...menu}>Settings</MenuItem>
        <MenuItem {...menu} disabled>
          Extensions
        </MenuItem>
        <MenuSeparator {...menu} />
        <MenuItem {...menu}>Keyboard shortcuts</MenuItem>
      </Menu>
    </>
  );
}
```

Да, кода кажется больше, но я бы не назвал это бойлерплейтом (избыточным шаблонным кодом) скорее в общем больше символов, но которые позволяют выделять ключевые атрибуты более явно и семантично - код в котором сущности (`MenuButton`, `MenuItem`) представлены не просто свойствами корневого компонента (`Menu`), а полноценными компонентами сразу понятно как модифицировать и вносить любые изменения - при этом документировать и тестировать такой код намного проще, потому что мы не вносим лишнюю вариативность расширением абстракций собственным API.

## UX

- есть множество общеиспользуемых компонентов, которых нет в нативке
- поведение этих компонентов не тривиально, т.к. может иметь множество состояний и их переходов

## UX и a11y

Помимо описанных выше системных проблем при разработке переиспользуемых и настраиваемых компонентов всегда, я уверен, встает вопрос качественного UX, который реализовать совсем не просто. Тот же компонент Menu содержит немалый перечень паттернов дружественного поведения, которые не выразить просто нативными средствами браузера. Например: появление списка в относительно большей области вьюпорта, зацикленное перемещение фокуса, a11y и [т.д.](https://www.w3.org/TR/wai-aria-practices/#menu). Reakit больше всего заботится и предоставляет функциональность этих лучших UX практик из коробки! Как [говорит сам автор](https://twitter.com/diegohaz/status/1232325270733979648), с Reakit вы даже не замечаете как делаете ваши компоненты лучше и полноценнее.

Основный посыл данной статьи именно в том что бы показать ui-toolkit который может не навязывать свой дизайн и ограничивать функциональность компонентов своим API, а предоставлять всю необходимую функциональность для простой реализации лучших практик пользовательского опыта. Хотелось бы что бы таких решений на рынке (OSS) было бы больше. Пока что я не встречал альтернатив Reakit: есть [rebass](https://rebassjs.org), но он не до конца расскрывает тему топик, как мне кажется, есть еще [reach-ui](https://reacttraining.com/reach-ui), который ближе к описанной идее, но все еще, хоть и немного, навязывает API шаблонов и стилизации.

## DX

- все из GUIDE https://reakit.io/docs
- https://twitter.com/diegohaz/status/1229499924062048260
- нет стилей, нет проблем со сборкой
- апи и документация подталкивают хорошо дизайнить интерфейсы компонентов
- хорошо тришейкается

<!-- ## Бонус: reshadow -->

<!-- https://github.com/sponsors/reakit -->
```
Reakit is a low level component library for building accessible high level UI libraries, design systems and applications with React. It provides components like Dialog, Menu, Tab, Tooltip, Form, among others that follow all the WAI-ARIA recommendations.
```
