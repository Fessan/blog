<!--
## Обо мне.

Больше 5 лет в ИТ: в разное время поддерживал, запускал, разрабатывал проекты в крупнейших финансовых компаниях РФ. Сейчас специализируюсь на разработке web-приложений: React.js и все что рядом. Люблю учиться и люблю это делать не в ширь, а в глубь, сейчас интересуюсь историей программирования и математическими науками.
## Название.

Формальная и интуитивная семантика языка программирования на примерах JS и JSX.

## Описание.

Всем известно что одну задачу, в большинстве своем, можно решить (запрограммировать) несколькими способами. Каждый из способов может отличаться архитектурой, паттернами, а так же кодстайлом, но как это выражать в максимально понятном виде, что может дать язык программирования для улучшения явности кода?

Я расскажу, на практических примерах, про фундаментальные характеристика языков программирования, которые дают понимание как писать понятный, дешевый (т.е. поддерживаемый) код в независимости от технологического стека.

## (для ПК)
Доклад я пишу вместе со статьёй (https://github.com/artalar/blog/blob/master/src/pages/semantics-in-programming.md), которую хотел бы опубликовать после доклада. Немного я уже затрагивал некоторые темы в своем предыдущем докладе: https://youtu.be/dCXvQkvSyQg?list=LLi6V1J5WfpPasQWskawcnVg&t=1663

- [Лекция 22: Формальная семантика языков функционального программирования](https://www.intuit.ru/studies/courses/471/327/lecture/7975?page=1)
- payload http://s.csssr.ru/U8SMMLH99/20190301205828.png
- https://habr.com/ru/company/oleg-bunin/blog/433326/
- [Языки программирования, синтаксис, семантика, прагматика](https://youtu.be/FtSWlpKuOKI)
- По поводу роутинга: завязываться на cdm - хардкодить БЛ в view
- https://medium.com/@stasonmars/5-советов-как-лучше-писать-условные-конструкции-в-javascript-236b31ecf299
- http://s.csssr.ru/U8SMMLH99/20190307175038.png
- http://s.csssr.ru/U8SMMLH99/20190307175130.png
- https://gist.github.com/artalar/6de0d1778bb62634214b69dbcb7090cb
- https://gist.github.com/8f6e9c2e1992fae55a23ad8ce8938d37
- как писать JSX? Представьте что это шаблон!
- [Моё разочарование в софте](https://habr.com/ru/post/423889/)
- https://multiparty.org/carousels/
- [Разница в семантике классов и хуков в React.js](https://twitter.com/threepointone/status/1056594421079261185)
- [Краткий пересказ утерянных глав руководства по фронтенду](https://docs.google.com/presentation/d/1-TI4ozHLV7IhujcmAsNkf58RBdrKQB37EUKtQ0UYmIM/)
-->

# Формальная и интуитивная семантика языка программирования на примерах JS и JSX.

## Введение

Мотивацией к написанию данного материала послужил постоянный внутренний дискомфорт от чтения чужого кода, который, должно быть, появляется у каждого. Какие-то конструкции кажутся избыточными или излишне сложными, какие-то вообще ошибочными. Иногда сложно понять какую бизнес-задачу пытался решить автор и, в частности, какие особенности языка или стека ему в этом мешали. И свой код спустя некоторое время становится малопонятным. Кажется, эта самая понятность исходит из контекстов: продукта, проекта, архитектуры и стека (фреймворки, библиотеки), команды и принятому кодстайлу. С этим ничего не сделаешь, просто приходится вновь погружаться во все эти контексты и искать связи между ними - только тогда каждая конструкция в коде обрастает понятной мотивацией, страх перед неизвестностью проходит и желание все переписать стихает.

Но, бывает, можно натолкнуться на чужой совершенно неизвестный код, который выглядит лаконичным и понятным. Сразу ясно какую задачу он решает и как. Причем такой код может быть даже на другом языке программирования или с использованием неизвестного стека, но, почему-то, он нормально читается, **интуитивно** рассказывая свою историю.

Вот и задаешься вопросом, есть ли, все же, какие-то универсальные правила построения и структурирования кода, которые бы не зависели от конкретного языка программирования или стека? Попробую найти ответ на этот вопрос копнув в самую глубь, попробовав понять что такое язык программирования в общем и какие он может иметь обобщенные особенности из которых можно вывести правила лучших практик.

> Хочется найти универсальную концепцию решения проблемы понимания кода. Т.е. выработать базовые / главные правила идеального кодстайла. Универсальную - т.е. фундаментальную, как это делают JSX и GraphQL в своей области.

## Декларативность

Многие называют "декларативное" программирование панацеей понятности и читаемости, но так ли это на самом деле? Почему кто-то с этим согласен на все 100%, а кто-то совершенно не разделяет энтузиазма по этому поводу? Как может панацея для кого-то быть не панацеей - это безсмыслица. Нужно разобраться.

Все, наверное, слышали чем декларативное программирование отличается от императивного: декларативное описывает **что** нужно сделать, а императивное **как** нужно сделать. Но говоря об этом обязательно стоит помнить, что при декларациях того что нужно сделать идет оперирование какими-то **существующими** элементами, о которых мы знаем **как** они работают (иначе наши декларации ничего бы не стоили). Декларативное программирование — это способ описания программы через набор **верхнеуровневых** инструкций, детали реализации и исполнения которых скрыты за исполнителем этих инструкций. Под исполнителем могут подразумеваться: функции высшего порядка (ramda, react, redux-saga), макросы (JSX) в случае кодогенерации, JIT компилятор в случае исполнения (синтаксис ЯП), машинные коды - декларативное описание логики переключения комплексных транзисторов. Т.е. средство описания [деклараций] всегда имеет какой-то контекст и "декларативность" означает не какой-то конкретный паттерн, а текущий уровень восприятия глубины абстракции разработчиком.

Например, классическим примером декларативного программирования является код в функциональном стиле:

> ```js
> array.filter(predicate)
> ```

Но что можно сказать про такой код:

> ```js
> instruction = { type: 'filter', target: array, arguments: [predicate] }
> ```

Этот код более декларативен - в нем нет прямого вызова функций, а только описание того что нужно сделать. Но как такое может быть, есть градации декларативности? А лучше ли этот код в плане читаемости и понимаемости? Кажется ответ не совсем однозначный.

Так же можно рассмотреть классический "императивный" код:

> ```js
> for (let i = 0; i < array.length; i++) if (predicate(array[i])) result.push(array[i])
> ```

Он кажется более сложным, чем приведенные снипеты выше, но если посмотреть на результирующий машинный код, то код с `for` и `if` покажется вполне простым и декларативным, т.к. он скрывает то **как** работать с памятью.

Из всего этого можно сделать простой вывод, "декларативность" - это термин для определения уровня абстракции, который для каждого человека может быть разным, в зависимости от контекста.

---

![](lost-chapters-of-frontend-book/2019-03-19-21-28-58.png)

Как-то на ревью ПР на работе я увидел чрезмерно "функциональный" подход в написании определенного набора действий и переписал этот код на "императивщину". На снимке экрана видно, что "императивный" код (справа) короче и в нем лучше выделены смысловые конструкции за счет их подсветки, но спрашивая коллег многие высказывались за то что функциональный код им нравится больше и стоит использовать его. Тогда я устроил голосование в чате. Как же было интересно узнать что мнение разделилось ровно поровну и кому-то был понятнее функциональный подход, а кому-то императивный:

![](http://s.csssr.ru/U8SMMLH99/20190307175130.png)

За функциональный подход выступало большое количество людей и многие из них были разработчиками с большим опытом - им хотелось доверять, но при этом результаты голосования показывали что не все так однозначно. В действительности те кто имел опыт и привык работать с библиотеками в функциональном стиле просто привыкли к такому паттерну и образу мышления, но это не означает что он является единственно верным.

И функциональный и императивный код решают одну и ту же задачу и дают один и тот же результат, но совершенно по разному читаются, воспринимаются и даже исполняются в JIT. Проще говоря - эти два кода имеют разную **семантику**.

P.S. код был в итоге переписан в функциональном стиле, но с вынесением определенной логики в отдельные функции.

---

## Семантика

<!--
> - Эволюция ЯП в улучшении абстракций: машинные коды, переменные (асемблер), процедуры и условные переходы (фортран), структуры (алгол68, паскаль), ООП, функции высшего порядка и развитые системы типов.
> - Но чем выше уровень абстракции, тем больше падает эффективность программы (условно, 1 уровен абстракции вдвое понижает вычислительную производительность)
> - **Алгол68** - имел на тот момент невероятно мощную и математически доказательную систему типов, но слишком сложную в использовании.
> - **COBOL** - на нем написано невероятно много кода, который до сих пор поддерживается, но ломающая версионность делает его использование очень сложным.
> - **ПЛ/1** - ЯП со свободным синтаксисом и [уникальной] возможностью управлять точностью вычислений. В нем можно было делать слишком много (приведение разнообразных типов) и разобраться в итоговом коде было сложно.
> - "логические" языки, вроде **PROLOG** сложно назвать языками *программирования*.
> - Изначально ООП подразумевал концепцию объектов, которые просто обмениваются сообщениями
> - Будущее программирования - функциональщина
-->

В изучении проблематики вопроса у меня не сразу получилось сформулировать о чем, с формальной точки зрения, вообще идет речь, есть ли для этого термин? Конечно я не первый задавался вопросами читаемости и явности кода, и на этот счет есть не мало трудов. Но большинство ответов (из первых страниц поисковых запросов) выдавали перечень прикладных советов, часть из которых могут быть реализованы только в некоторых языках (зависят от синтаксиса). Хотелось найти первопричину, а к ней простое и универсальное - элегантное решение, в котором не было бы противоречий. Например, следую классическим советам, упрощая код бизнес-задачи снижается портированность и переиспользование его частей. И наоборот, проектируя переиспользуемые компоненты очень сложно избежать ["зацепленности"](https://ru.wikipedia.org/wiki/Связность_(программирование)).

![](https://upload.wikimedia.org/wikipedia/ru/0/09/CouplingVsCohesion.svg)

Явность кода - это не только про code style, в плане визуального форматирования и именования переменных. Явность кода зависит от множества контекстов - это про микро и макро архитектуру всего приложения и принятых стандартов написания кода - это касается многого, но можно ли это обобщить? И тут я подумал - что объединяет все языки программирования? - то что это **языки** программирования.

![](https://www.paoloratto.com/wp-content/uploads/2010/09/facebookfriendwheel.jpg)

**Язык** в общем и язык программирования в частности - это **синтаксис** и **семантика** (еще прагматика). Две ключевых составляющих, которые определяют что такое язык, как им пользоваться и выражать на нем свои мысли. И если с синтаксисом все более-менее понятно - это описание ключевых слов и т.п., то что такое семантика можно долго и упорно (не) понимать, хотя мне понятно - что все ответы в ней, на вопросы явности в коде.

Вообще язык сам по себе - это сложная сущность, формализованные части которой так же сложно понять. Википедиа говорит:

**Си́нтаксис** (др.-греч. σύν-ταξις — составление) — раздел лингвистики, изучающий строение и функциональное взаимодействие различных частей речи в предложениях, словосочетаниях и пр. языковых единицах. Является составной частью грамматики.

**Сема́нтика** (от др.-греч. σημαντικός «обозначающий») — раздел лингвистики, изучающий смысловое значение единиц языка.

> Наличие семантики - наличие явности выражения мысли.

Ну вот определения, ну вот они что-то описывают, но что это в действительности значит и как это можно использовать? Все понимается проще на аналогиях и можно попытаться найти их для определения синтаксиса и семантики, применительно к ЯП. Например: если синтаксис - это какой-то инструмент, то семантика - это правила пользования инструментом.

Если попробовать детально разобраться в семантике, как составляющей программного языка, то можно прийти к истории, общей теории языков программирования и, в частности, области компиляторов и формальному (математическому) доказательству корректности программ. Есть хорошая [лекция](https://youtu.be/FtSWlpKuOKI) университетского курса "Языки программирования и компиляторы".

Вообще машина - это большой конечный автомат, точнее конечный преобразователь (трансдьюсер). Ее инструкции - набор переходов. Человеку же сложно оперировать такими понятиями, особенно в большой программе, он в принципе мыслит иначе и для [быстрого] понимания чего-то часто применяет **интуицию**, обобщая логику описания поведения (программы). Мостом же между инструкциями вычислительной машины и человеком выступает слой абстракций, который называется язык программирования (ЯП). Вообще перебор возможных вариантов работы (с данными для решения задачи) при написании программы очень похож на формальное математическое доказательство - эта похожесть называется ["Соответствие Карри — Ховарда"](https://ru.wikipedia.org/wiki/Соответствие_Карри_—_Ховарда). Но отличие математического доказательства от написания программы заключается в том что логика построения программы, в первую очередь, строится не на формальных доказательствах, а интуитивных умозаключениях программиста, которые он уже пытается наложить на формальные правила ЯП. Понятно что каждую задачу можно описать на ЯП по разному. Это, в частности, зависит и от личного представления программиста о задаче, от его привычек и способа мышления, умения использовать то или иное API языка, библиотек, фреймворков. Но как соотнести абстрактное представление программиста о задаче с четким и формальным алгоритмом, можно ли формализовать это соотношение? Есть ли какое-то правило, функция, которая описывает и представляет разницу между индивидуальным кодом программиста и формальным необходимым результатом? Вот это, как раз, и называется **семантика**.

> Синтаксис - для парсинга AST и построения структуры программы

> Семантика - для понимания программы компилятором и интерпритатором

В итоге. **Семантика позволяет конкретизировать до формального уровня интуитивное представление кода программы**. Иначе говоря "с первого взгляда" код может иметь одну логику поведения, но учитывая семантику можно "увидеть" дополнительные аспекты \ ветвления алгоритма.

Говоря точнее есть две семантики: формальная и интуитивная. **Формальная семантика** - это четкое представление кода программы в инструкции, она описывается спецификацией языка и используется компилятором или линтером для логического анализа кода и ошибок в нем. **Интуитивная семантика** - это примерное представление программиста о логике, которую воплащает код программы, она менее формализованная, но быстрее, так сказать, парсится (человеком).

## Прикладные примеры

### `null` VS `undefined`

**null** - это намеренно пустое значение. **undefined** - это неожиданно пустое значение, подсказка-хелпер рантайм мира, которой в статически-типизированных ЯП не бывает (там undefined == TypeError).

С интуитивной точки зрения, поверхностного взгляда, и null и undefined означают пустое значение и имеют одно и тоже поведение, но с точки зрения формальной семантики это разные конструкции, что проявляется в мелочах. Например, если выражение `obj.prop === null` верно можно быть уверенным что свойство `prop` целенаправленно установлено в объекте где-то в предыдущем исполнении кода. Но если выражение `obj.prop === undefined` верно, то нет никаких гарантий что свойство `prop` вообще есть в объекте, с null такой проблемы нет.

<!-- FIXME: заменить название -->
### Cсылочная прозрачность

```js
// [1]
setTimeout(f, 0, argument)
// [2]
setTimeout(() => f(argument), 0)
```

Два небольших снипета кода, приведенных выше, с точки зрения интуитивной семантики - постановки задачи одинаковые. Однако фактически они различаются и интересно то на что это может повлиять. Строго говоря у второго варианта отсутствует ссылочная прозрачность - колбек который будет выполнен зависит от переменной, которая может быть изменена после инициализации таймаута, но до выполнения колбека, в первом варианте это невозможно, т.к. аргумент передается по ссылке, а не через переменную замыкания.

Это очень хороший пример того что такое семантика и зачем она нужна. Семантика часто отвечает за контекст или множество контекстов, которые могут касаться рассматриваемого кода: в зависимости от используемых синтаксических конструкций ЯП и API библиотек может быть очень много особенностей и "подводных камней", которые не понятны, если не проанализировать всю семантику - все, с формальной точки зрения, особенности. Из этого просто сделать вывод что тот код проще (читать, понимать, прогнозировать поведение), у которого семантика, как бы, меньше. Это общее правило и вывод данного материала - нужно стараться сводить семантику на нет или точно знать какая она может быть в рассматриваемом участке кода, что бы было понятнее и надежнее разрабатывать и читать код.

### Тонкости спецификации

```js
// [1]
console.log({ '2': null, ...({ '1': null, '2': null }) })
// [2]
console.log({ '2.0': null, ...({ '1.0': null, '2.0': null }) })
```

С первого взгляда может показаться что это очень похожий код, результат которого тоже будет очень похож. Но, согласно спецификации сортировка свойств объекта имеет некоторые особенности, в результате которых в первом случае результат будет `{1: null, 2: null}`, а во втором `{2.0: null, 1.0: null}`. Как можно заметить, во втором варианте порядок свойств поменялся. Эта логика не интуитивно понятна и описывается, как раз, семантикой.

### Паттерн "заместитель"

```js
// [1]
function include(array, target) {
  for (let i = 0; i < array.length; i++) {
    if (array[i] === target) return true;
  }
  return false;
}
// [2]
function include(array, target) {
  for (const element of array) {
    if (element === target) return true;
  }
  return false;
}
```

Вот, еще один, похожий код. Интересный вопрос, какая у него может быть разница в производительности и почему? Продвинутые знания ЯП о работе итераторов могут подсказать, что `for of` должен быть медленнее, но здесь скрывается еще одна хитрая проблема.

Proxy, get и set - реализуют паттерн "заместитель", при котором возможно перехватить обращение к свойствам целевого объекта для выполнения какой-то дополнительной логики. Проблема этого паттерна в том что он воздействует на поведение программы, но это [воздействие] никак не отражается *визуально* для программиста. Т.е. говоря об интуитивной семантике - в этом паттерне она вообще никак не отображается и невозможно понять есть она или нет. Хотя с точки зрения формальной семантики, в процессе исполнения, интерпритатор точно будет знать есть там прокси или нет. Из этого можно сделать вывод что не явный код - это код в котором интуитивная и формальная семантика имеют различия (чем их больше - тем код неявнее).

Если сравнить код `1` и `2`, то понятно что с функциональной точки зрения разницы в нем нет, но если `array` будет обернут в прокси, то каждый вызов `array[i]` будет "утяжелен" перехватчиком, поэтому у этого, казалось бы, одинакового кода может быть заметная (в разы) разница в производительности в пользу варианта с `for of`.

Если в проекте используются прокси или геттеры и сеттеры, то в любой случайной точке кодовой базы никогда нельзя быть до конца уверенным есть здесь они или нет. Это невидимый контекст, что бы узнать о котором иногда, особенно в больших проектах, требуется исследовать большое количество связанного кода. Таким образом приходится либо постоянно быть не уверенным в читаемом коде, либо производить его многочисленные инспекции. Решением этой проблемы может быть использование паттерна "декоратор", или любое *явное* использование контекста и зависимостей.

### JSX VS JS

> JSX должен быть в JS, а не JS в JSX. Top level синтаксис в файле - это JS, сам JSX пишется только между открывающим и закрывающим тегом, соответственно там необходимо иметь минимум JS. - вот весь, простой, принцип.

![](lost-chapters-of-frontend-book/2019-03-18-10-18-38.png)

JSX с точки зрения интуитивной семантики - верстка, он отвечает за то ***что*** будет отображаться, а не ***как***, потому что его задача именно в инкапсуляции логики `document.createElement` (формальной семантики). И на этом примере можно понять что хорошая декларативность / метапрограммирование - это когда фактической разницы в результате работы кода с точки зрения интуитивной и формальной семантики нет. Но возвращаясь к JSX он как и результат самого HTML всегда должен быть статичен, в независимости от данных. В подтверждение этому выступает апи хуков жизненного цикла - оно описывается в JS - это наглядно.

![](lost-chapters-of-frontend-book/2019-03-18-10-19-30.png)

Например, `react-router` является примером очень плохого апи, т.к. через компонент `<Switch>` он предлагает описывать логику зависимостей от данных прямо в JSX (более того, сам элемент превращается в управляющий блок) - при этом классическая семантика полностью рушится, что ведет к ментальному усложнению чтения кода - в голове нужно держать больше контекста. Правильнее в JS (в начале блока функционального компонента или метода `render`) описывать все зависимости - высчитывать их и потом в конечный возвращаемый JSX вставлять все необходимое: `title = predicate ? 'first' : 'second'; return <span>{title}</span>` - это и есть декларативное описание.

Желание описать роутинг (или что угодно еще, есть даже библиотека с компонентами `<If>`, `<For>`) декларативно - понятно, т.к. это кажется нагляднее и проще (хотя не все так просто, потому что `пониманиеАбстракции = время(документация)`). Но нужно понимать, что декларативное описание не обязано иметь единственный синтаксис \ шаблон. JSX - это декларативный синтаксис к описанию биндинга модели приложения на DOM, и это означает что его **не** нужно использовать для декларативного описания конструкций, которые не относятся к DOM напрямую. Для написания декларативного кода можно использовать, например, библиотеку [Ramda](https://ramdajs.com), писать [макросы](https://github.com/kentcdodds/babel-plugin-macros) и много другое.

Так же роутер нарушает принци SSoT, если в приложении имеется глобальный стейт менеджер, из-за чего компоненты использующие и роутер и стор часто имеют какие-то костыли или выступают мостом между двумя стейтами. Хорошим решением было бы использование роутинга через глобальный стор.

---

![](lost-chapters-of-frontend-book/2019-03-18-10-21-22.png)

Есть подход "рендерМетодов", который подразумевает вынесение каких-то логических частей JSX в отдельные методы, но проблема с ним заключается в том что связанность такого кода сильно увеличена из-за разброса props и не отсутствия отображения этих методов в react-devtools (отображается просто портянка JSX, не понятно откуда взявшаяся). В каждом участке кода класса с рендерМетодами семантическая нагрузка определенно завышена.

![](lost-chapters-of-frontend-book/2019-03-18-10-21-48.png)

Что бы избежать проблем с рендерМетодами достаточно вынести их тело в отдельные компоненты. При этом их проще будет отследить в react-devtools, а некоторые зависимости класса, которые получаются из контекста, скорее всего получится перенести в новые дочерние компоненты и разгрузить таким образом связанность в родительском компоненте.

---

"render-props" через `children` тоже подходит на явный пример антипатерна семантики. Да, сам подход хорошо решает технические проблемы, но сильно ухудшает читаемость кода, нарушая принципы ответственности JSX. Решением может быть использование [сведе'ния](https://github.com/pedronauck/react-adopt) render-prop'ов.

Плохие советы по рендер-пропам дают даже css-tricks - https://css-tricks.com/an-overview-of-render-props-in-react/

![](lost-chapters-of-frontend-book/2019-03-18-10-31-56.png)

Можно попробовать не использовать JSX для контейнеров. Интересно, что тогда код больше похож на использование хуков.

![](lost-chapters-of-frontend-book/2019-03-18-10-32-19.png)

---

<!-- FIXME: не понятно причем тут семантика -->

Показательным примером важности семантики расстановки блоков кода являются новые хуки в React.js
<!-- https://twitter.com/threepointone/status/1056594421079261185
![](https://pbs.twimg.com/media/DqnGs6yWwAAYPXp.jpg:large)
![](https://pbs.twimg.com/media/DqnGuEnWsAAt1Xt.jpg:large)
-->
![](lost-chapters-of-frontend-book/2019-03-21-14-18-27.png)

В этом примере код на классах был переписан на хуки и, помимо сокращения количества строк, можно увидеть что смысловые блоки сгруппировались, благодаря чему понимать какие-то конкретные процессы, описанные кодом, стало проще. Т.е. интуитивную семантику можно повышать не только за счет другого синтаксиса, но и за счет правильной расстановки блоков кода.

## Вывод

Говоря обобщенно за кодочитаемость отвечает семантика. В частности под этим может подразумеваться множество аспектов языка: правильно использование типов данных и их особенностей, синтаксических конструкций, реализованных паттернов программирования (прокси), макросов и метапрограммирования и многое другое. Конечно, невозможно охватить такое многообразие перечнем небольших и конкретных правил, которые помогут писать исключительно идеальный код. Но общий вывод я мог бы сделать такой: явный код не содержит скрытых контекстов или скрытого поведения.

> ### Читаемость и понятность кода лучше когда разница между интуитивной и формальной семантикой отсутствует.

<!-- ## Линтеры

> TODO:
> - Добавить ссылки на плагины проверяющие логические ошибки, разобрать их.
> - Погуглить и почитать про семантически-ориентированный линтинг.
> - Добавить рассуждения связи линтера и семантики.

Lint или линтер - это статический анализатор кода, который изначально был продуктом для языка Си, но в последствии стал нарицательным словом для обозначения подобных инструментов общего класса. Линтер - это инструмент отслеживания "не правильного" использования конструкций языка, в результате которых повышается вероятность возникновения ошибки. Он позволяет находить ошибки в коде еще до его компиляции (у JS это происходит в рантайме), чем, в итоге, упрощает и ускоряет разработку. Примеры ошибок, которые может отследить линтер: неиспользуемые переменные (предупреждение), отсутствие `default` в `switch` (логическая ошибка), повторное объявление переменных (ошибка) или свойств объекта, ошибка в конструкциях языка (пропущенный `catch` после `try`). Есть возможность отсеживания и более сложных контекстно-логических ошибок, например использование индекса элемента массива, для указания `key` компоненту, при мапинге по списку в JSX.

Так же одной из возможностей линтеров является проверка стилистики форматирования кода (отступы, переносы строк и т.п.) определенному шаблону, но это лишь побочная функция. Например, инструмент [Prettier](https://prettier.io) занимается только форматированием стилистики кода (его текста) и не производит анализ уместности конструкций языка, написанных разработчиком. Поэтому не верно утверждать, что prettier может заменить линтер или наоборот - это разные инструменты. Это же касается и систем типизации, вроде TypeScript или Flow - они осуществляют проверку совместимости операторов и выражений для разных типов данных, но не проверяют как эти операторы или выражения записаны.

Использование линтера является стандартом и необходимостью в современной разработке. Для JavaScript самым популярным линтером является [ESLint](https://eslint.org) (а [вот](https://www.npmjs.com/package/eslint-config-airbnb) самый популярный конфиг для него), хотя у него есть альтернатива - [JSHint](http://jshint.com). Так же линтеры [есть](https://stylelint.io) и для CSS.

## Структура проекта

> TODO:
> - Структура проекта как визуальное средство верхнеуровнего представления программы
-->
