<!--
Обо мне.
5+ лет в ИТ, 2+ года во фронтенде, CSSSR.
Название.
Семантика в программировании или явность кода на примерах JS и JSX.
Описание.
Всем известно что одну задачу, в большинстве своем, можно решить (запрограммировать) несколькими способами. Каждый из способов может отличаться архитектурой, разнообразными паттернами, а так же кодстайлом, о котором и пойдет речь в моем докладе. Я расскажу не просто про форматирование кода, в стиле выбора максимальной длины строки, а про архитектурные и прикладные советы, которые помогут в написании явного, понятного, дешевого (т.е. поддерживаемого) кода.
(для ПК) Темы: семантические особенности JS и JSX, линтеры, декларативное программирование, структура проекта. Частично я уже затрагивал некоторые темы в своем предыдущем докладе: https://youtu.be/dCXvQkvSyQg?list=LLi6V1J5WfpPasQWskawcnVg&t=1663
-->

# Семантика в программировании или явность кода на примерах JS и JSX.

## Мотивация

Мотивацией к написанию данного материала послужил постоянный внутренний дискомфорт от чтения чужого кода. Вам это знакомо? Опытные программисты знают, что и свой код спустя некоторое время становится малопонятным. И, казалось бы, эта самая понятность исходит из контекстов: продукта, проекта, стека, команды и принятых соглашений, с этим ничего не сделаешь по прошествию лет. Но, бывает, можно натолкнуться на чужой, совершенно неизвестный код, который выглядит лаконичным и понятным. Так есть ли, все же, какие-то универсальные правила построения и структурирования кода, которые бы не зависели от конкретного языка программирования? Попробуем найти ответ на этот вопрос копнув в самую глубь - семантику языка программирования. А потом рассмотрим как применить новые знания к коду современного стека web-приложения: ES6+, JSX.

## Семантика

![](lost-chapters-of-frontend-book/semantics-description.png)

> TODO:
> - примеры в HTML
> - примеры в JS
> - примеры в JSX

Если вы попробуете разобраться в семантике программного языка детально, то окажется что это больше относится к области компиляторов и формальному (математическому) доказательству корректности программ. Но, попробую, описать все это вкратце и верхнеуровнево.

Машина - это большой конечный автомат, точнее конечный преобразователь (трансдьюсер). Ее инструкции - набор переходов. Человеку сложно оперировать такими понятиями, особенно в большой программе, он в принципе мыслит иначе, для [быстрого] понимания чего-то часто применяя интуицию.

<!--
> - Эволюция ЯП в улучшении абстракций: машинные коды, переменные (асемблер), процедуры и условные переходы (фортран), структуры (алгол68, паскаль), ООП, функции высшего порядка и развитые системы типов.
> - Но чем выше уровень абстракции, тем больше падает эффективность программы (условно, 1 уровен абстракции вдвое понижает вычислительную производительность)
> - **Алгол68** - имел на тот момент невероятно мощную и математически доказательную систему типов, но слишком сложную в использовании.
> - **COBOL** - на нем написано невероятно много кода, который до сих пор поддерживается, но ломающая версионность делает его использование очень сложным.
> - **ПЛ/1** - ЯП со свободным синтаксисом и [уникальной] возможностью управлять точностью вычислений. В нем можно было делать слишком много (приведение разнообразных типов) и разобраться в итоговом коде было сложно.
> - "логические" языки, вроде **PROLOG** сложно назвать языками *программирования*.
> - Изначально ООП подразумевал концепцию объектов, которые просто обмениваются сообщениями
> - Будущее программирования - функциональщина
-->

**Язык** в общем и язык программирования в частности - это **синтаксис** (набор правил формализации) и **семантика** (описание семантического домена - набора функций).

Перебор возможных вариантов работы [с данными] программы очень похоже формальное математическое доказательство - это называется *Соответствие Карри — Ховарда*. Отличие, от математического доказательства, написание программы заключается в том что логика построения программы строится не на формальных доказательствах, а интуитивных умозаключениях программиста (накладывая абстрактный мыслительный процесс на формализацию ЯП).

В итоге. **Семантика позволяет конкретизировать до формального уровня интуитивное представление кода программы**. Иначе говоря "с первого взгляда" код может иметь одну логику поведения, но учитывая семантику можно "увидеть" дополнительные аспекты \ ветвления алгоритма.

## Линтеры

> TODO:
> - Добавить ссылки на плагины проверяющие логические ошибки, разобрать их

Lint или линтер - это статический анализатор кода, который изначально был продуктом для языка Си, но в последствии стал нарицательным словом для обозначения подобных инструментов общего класса. Линтер - это инструмент отслеживания "не правильного" использования конструкций языка, в результате которых повышается вероятность возникновения ошибки. Он позволяет находить ошибки в коде еще до его компиляции (у JS это происходит в рантайме), чем, в итоге, упрощает и ускоряет разработку. Примеры ошибок, которые может отследить линтер: неиспользуемые переменные (предупреждение), отсутствие `default` в `switch` (логическая ошибка), повторное объявление переменных (ошибка) или свойств объекта, ошибка в конструкциях языка (пропущенный `catch` после `try`). Есть возможность отсеживания и более сложных контекстно-логических ошибок, например использование индекса элемента массива, для указания `key` компоненту, при мапинге по списку в JSX.

Так же одной из возможностей линтеров является проверка стилистики форматирования кода (отступы, переносы строк и т.п.) определенному шаблону, но это лишь побочная функция. Например, инструмент [Prettier](https://prettier.io) занимается только форматированием стилистики кода (его текста) и не производит анализ уместности конструкций языка, написанных разработчиком. Поэтому не верно утверждать, что prettier может заменить линтер или наоборот - это разные инструменты. Это же касается и систем типизации, вроде TypeScript или Flow - они осуществляют проверку совместимости операторов и выражений для разных типов данных, но не проверяют как эти операторы или выражения записаны.

Использование линтера является стандартом и необходимостью в современной разработке. Для JavaScript самым популярным линтером является [ESLint](https://eslint.org) (а [вот](https://www.npmjs.com/package/eslint-config-airbnb) самый популярный конфиг для него), хотя у него есть альтернатива - [JSHint](http://jshint.com). Так же линтеры [есть](https://stylelint.io) и для CSS.

## Декларативное программирование

> TODO:
> - метапрограммирование
> - примеры библиотек для декларативного описания кода, babel-macro

Декларативное программирование — это способ описания программы через набор верхнеуровневых инструкций, детали реализации и исполнения которых скрыты за исполнителем этих инструкций.

Императивное программирование предполагает описывать инструкции и их последовательные связи с использованием низкоуровневых (в рамках языка программирования) выражений.

Как можно понять, все операторы выражения — в действительности задекларированные языком программирования инструкция. Но каждая инструкция - это описание какого-то выражения. Таким образом императивное и декларативное программирование - это условности глубины абстракции и контекста рассматриваемого кода программы.

## Структура проекта

> TODO:
> - Структура проекта как визуальное средство верхнеуровнего представления программы
