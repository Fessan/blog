<!--
Обо мне.
5+ лет в ИТ, 2+ года во фронтенде, CSSSR.
Название.
Семантика в программировании или явность кода на примерах JS и JSX.
Описание.
Всем известно что одну задачу, в большинстве своем, можно решить (запрограммировать) несколькими способами. Каждый из способов может отличаться архитектурой, разнообразными паттернами, а так же кодстайлом, о котором и пойдет речь в моем докладе. Я расскажу не просто про форматирование кода, в стиле выбора максимальной длины строки, а про архитектурные и прикладные советы, которые помогут в написании явного, понятного, дешевого (т.е. поддерживаемого) кода.
(для ПК) Темы: семантические особенности JS и JSX, линтеры, декларативное программирование, структура проекта. Частично я уже затрагивал некоторые темы в своем предыдущем докладе: https://youtu.be/dCXvQkvSyQg?list=LLi6V1J5WfpPasQWskawcnVg&t=1663

- [Лекция 22: Формальная семантика языков функционального программирования](https://www.intuit.ru/studies/courses/471/327/lecture/7975?page=1)
- payload http://s.csssr.ru/U8SMMLH99/20190301205828.png
- https://habr.com/ru/company/oleg-bunin/blog/433326/
- [Языки программирования, синтаксис, семантика, прагматика](https://youtu.be/FtSWlpKuOKI)
- По поводу роутинга: завязываться на cdm - хардкодить БЛ в view
- https://medium.com/@stasonmars/5-советов-как-лучше-писать-условные-конструкции-в-javascript-236b31ecf299
- http://s.csssr.ru/U8SMMLH99/20190307175038.png
- http://s.csssr.ru/U8SMMLH99/20190307175130.png
- https://gist.github.com/artalar/6de0d1778bb62634214b69dbcb7090cb
- https://gist.github.com/8f6e9c2e1992fae55a23ad8ce8938d37
- как писать JSX? Представьте что это шаблон!
- [Моё разочарование в софте](https://habr.com/ru/post/423889/)
- https://multiparty.org/carousels/
-->

# Семантика в программировании или явность кода на примерах JS и JSX.

## Мотивация

Мотивацией к написанию данного материала послужил постоянный внутренний дискомфорт от чтения чужого кода. Вам это знакомо? Опытные программисты знают, что и свой код спустя некоторое время становится малопонятным. И, казалось бы, эта самая понятность исходит из контекстов: продукта, проекта, стека, команды и принятых соглашений, с этим ничего не сделаешь по прошествию лет. Но, бывает, можно натолкнуться на чужой, совершенно неизвестный код, который выглядит лаконичным и понятным. Так есть ли, все же, какие-то универсальные правила построения и структурирования кода, которые бы не зависели от конкретного языка программирования? Попробуем найти ответ на этот вопрос копнув в самую глубь - семантику языка программирования. А потом рассмотрим как применить новые знания к коду современного стека web-приложения: ES6+, JSX.

> Хочется найти универсальную концепцию решения проблемы понимания кодстайла. Универсальную - т.е. фундаментальную, как это делают JSX и GraphQL в своей области.

## Семантика

![](lost-chapters-of-frontend-book/semantics-description.png)

> TODO:
> - примеры в HTML
> - примеры в JS
> - примеры в JSX

Если вы попробуете разобраться в семантике программного языка детально, то окажется что это больше относится к области компиляторов и формальному (математическому) доказательству корректности программ. Но попробую описать все это вкратце и верхнеуровнево.

Машина - это большой конечный автомат, точнее конечный преобразователь (трансдьюсер). Ее инструкции - набор переходов. Человеку сложно оперировать такими понятиями, особенно в большой программе, он в принципе мыслит иначе, для [быстрого] понимания чего-то часто применяя интуицию.

<!--
> - Эволюция ЯП в улучшении абстракций: машинные коды, переменные (асемблер), процедуры и условные переходы (фортран), структуры (алгол68, паскаль), ООП, функции высшего порядка и развитые системы типов.
> - Но чем выше уровень абстракции, тем больше падает эффективность программы (условно, 1 уровен абстракции вдвое понижает вычислительную производительность)
> - **Алгол68** - имел на тот момент невероятно мощную и математически доказательную систему типов, но слишком сложную в использовании.
> - **COBOL** - на нем написано невероятно много кода, который до сих пор поддерживается, но ломающая версионность делает его использование очень сложным.
> - **ПЛ/1** - ЯП со свободным синтаксисом и [уникальной] возможностью управлять точностью вычислений. В нем можно было делать слишком много (приведение разнообразных типов) и разобраться в итоговом коде было сложно.
> - "логические" языки, вроде **PROLOG** сложно назвать языками *программирования*.
> - Изначально ООП подразумевал концепцию объектов, которые просто обмениваются сообщениями
> - Будущее программирования - функциональщина
-->

**Язык** в общем и язык программирования в частности - это **синтаксис** (набор правил формализации) и **семантика** (описание семантического домена - набора функций).

Перебор возможных вариантов работы [с данными] при написании программы очень похож на формальное математическое доказательство - это называется *Соответствие Карри — Ховарда*. Но в отличии от математического доказательства написание программы заключается в том что логика построения программы строится не на формальных доказательствах, а интуитивных умозаключениях программиста, которые он уже пытается наложить на формальные правила ЯП.

Понятно что каждую задачу можно описать на ЯП по разному. Это, в частности, зависит и от личного представления программиста о задаче, от его привычек и способа мышления. Но как соотнести абстрактное представление программиста о задаче с четким и формальным алгоритмом? Есть ли какое-то правило, функция, которая описывает и представляет разницу между индивидуальным кодом программиста и формальным необходимым результатом? Да, это и называется семантика.

<!-- TODO: какая-то каша, а не описание -->

В итоге. **Семантика позволяет конкретизировать до формального уровня интуитивное представление кода программы**. Иначе говоря "с первого взгляда" код может иметь одну логику поведения, но учитывая семантику можно "увидеть" дополнительные аспекты \ ветвления алгоритма.

## Декларативность

> TODO:
> - метапрограммирование
> - примеры библиотек для декларативного описания кода, babel-macro



<!--
Императивное программирование предполагает описывать инструкции и их последовательные связи с использованием низкоуровневых (в рамках языка программирования) выражений.
Как можно понять, все операторы выражения — в действительности задекларированные языком программирования инструкция. Но каждая инструкция - это описание какого-то выражения. Таким образом императивное и декларативное программирование - это условности глубины абстракции и контекста рассматриваемого кода программы.
-->

Все, наверное, слышали чем декларативное программирование отличается от императивного: декларативное описывает **что** нужно сделать, а императивное **как** нужно сделать. Но говоря об этом обязательно стоит помнить, что при декларациях того что нужно сделать идет оперирование какими-то существующими элементами, о которых мы знаем **как** они работают (иначе наши декларации ничего бы не стоили). Декларативное программирование — это способ описания программы через набор верхнеуровневых инструкций, детали реализации и исполнения которых скрыты за исполнителем этих инструкций. Под исполнителем могут подразумеваться: функции высшего порядка (ramda, react, redux-saga), макросы (babel) в случае кодогенерации, JIT компилятор в случае исполнения. Т.е. средство описания [деклараций] всегда имеет какой-то контекст и "декларативность" означает не какой-то конкретный паттерн, а текущий уровень восприятия глубины абстракции разработчиком.

Как-то на ревью ПР на работе я увидел неудачное использование функционального подхода в написании определенного набора действий и переписал этот код на "императивщину" (https://gist.github.com/artalar/6de0d1778bb62634214b69dbcb7090cb). Спрашивая коллег многие высказывались за то что функциональный код выглядел лучше, тогда я устроил голосование в чате. Как же было интересно узнать что мнение разделилось ровно поровну и кому-то был понятнее функциональный подход, а кому-то императивный:

![](http://s.csssr.ru/U8SMMLH99/20190307175130.png)

За функциональный подход выступало большое количество людей и многие из них были разработчиками с большим опытом - им хотелось доверять, но при этом результаты голосования показывали что не все так однозначно. В действительности те кто имел опыт и привык работать с библиотеками в функциональном стиле просто привыкли к такому паттерну и образу мышления, но это не означает что он является единственно верным.

И функциональный и императивный код выполняют одну и ту же работу и дают один и тот же результат, но совершенно по разному читается, воспринимается и даже исполняется в JIT. Проще говоря - имеют разную семантику.

## Линтеры

> TODO:
> - Добавить ссылки на плагины проверяющие логические ошибки, разобрать их

Lint или линтер - это статический анализатор кода, который изначально был продуктом для языка Си, но в последствии стал нарицательным словом для обозначения подобных инструментов общего класса. Линтер - это инструмент отслеживания "не правильного" использования конструкций языка, в результате которых повышается вероятность возникновения ошибки. Он позволяет находить ошибки в коде еще до его компиляции (у JS это происходит в рантайме), чем, в итоге, упрощает и ускоряет разработку. Примеры ошибок, которые может отследить линтер: неиспользуемые переменные (предупреждение), отсутствие `default` в `switch` (логическая ошибка), повторное объявление переменных (ошибка) или свойств объекта, ошибка в конструкциях языка (пропущенный `catch` после `try`). Есть возможность отсеживания и более сложных контекстно-логических ошибок, например использование индекса элемента массива, для указания `key` компоненту, при мапинге по списку в JSX.

Так же одной из возможностей линтеров является проверка стилистики форматирования кода (отступы, переносы строк и т.п.) определенному шаблону, но это лишь побочная функция. Например, инструмент [Prettier](https://prettier.io) занимается только форматированием стилистики кода (его текста) и не производит анализ уместности конструкций языка, написанных разработчиком. Поэтому не верно утверждать, что prettier может заменить линтер или наоборот - это разные инструменты. Это же касается и систем типизации, вроде TypeScript или Flow - они осуществляют проверку совместимости операторов и выражений для разных типов данных, но не проверяют как эти операторы или выражения записаны.

Использование линтера является стандартом и необходимостью в современной разработке. Для JavaScript самым популярным линтером является [ESLint](https://eslint.org) (а [вот](https://www.npmjs.com/package/eslint-config-airbnb) самый популярный конфиг для него), хотя у него есть альтернатива - [JSHint](http://jshint.com). Так же линтеры [есть](https://stylelint.io) и для CSS.

## Структура проекта

> TODO:
> - Структура проекта как визуальное средство верхнеуровнего представления программы
