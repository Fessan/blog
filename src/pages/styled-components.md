> [Видео с докладом](https://youtu.be/eOBz3_mQwo8?list=LLAKtelC0m6GfyYcLVcujTvg)

> [Файл презентации](https://github.com/artalar/blog/blob/master/src/assets/artalar_meetup 23.05.pdf)

# styled-components

Данный цикл статей посвящен библиотеке **styled-components** (**SC**): зачем она нужна и какие проблемы решает, почему CSS in JS, примеры использования, а так же гайдлайн использования для проекта больше "TODO list".

## В первую очередь

Многими SC воспринимается просто как еще одна библиотека в экосистеме React для написания CSS в javascript коде, но помимо этого есть еще один важный момент. Не сложно догадаться, что "styled components" переводится как "стилизованные компоненты" и это неспроста. Название говорит само за себя, как и **веб компоненты** ([Web Components](https://developer.mozilla.org/ru/docs/Web/Web_Components)), SC предлагает не просто набор технологий, но и новый архитектурный подход к построению веб-интерфейсов.

Мы привыкли, что HTML, CSS и JS - обособленные технологии, каждая из которых имеет свой набор ответственностей и практик. И абстракции в архитектуре нашего кода были построены вокруг этих технологий, отодвигая на второй план абстракции конечного продукта. Т.е. сама структура нашего кода завязла не на решение задач продукта, который мы делаем, а на удовлетворение использованных технологий. Но это начинает меняться, что можно наблюдать по современным фреймворкам и предложенным ими решениям. В частности, в JSX технологии (HTML и JS) начинают сливаться, что бы привнести декларативность в их неотъемлемую связанность.

В свою очередь, **SC** не еще один "сахарный" способ написания CSS, которыми являются препроцессоры вроде Sass и LESS. В первую очередь это другой взгляд на архитектуру составных элементов веб-приложений и сейчас мы разберем почему.

Давайте, сначала, определимся что такое "компонент". Компонент - это абстрактный элемент, который содержит в себе какую-то функциональность. Есть разные классификации и типы компонентов: _dumb / presentational, smart / container / HOC / provider / consumer..._ и т.п. Все они призваны разделять и делегировать на себя часть конкретных функциональных обязанностей в архитектуре приложения. Так мы имеем компоненты высшего порядка - отвечающие за логику и преобразования состояния приложение. И компоненты _представления_, отвечающие за визуальную часть приложения и включающие в себя логику интерактивности, положения и отображения данных на странице. Но на сколько элементарной частицей может быть компонент представления? В популярном подходе по разработке интерфейсов - [Atomic Design](https://medium.com/атомарный-дизайн/atomic-design-foreword-4960ad17bc1a) есть понятие "атома". Например, это может быть просто поле ввода или кнопка, т.е. компонент состоящий всего из одного DOM элемента. У некоторых разработчиков есть заблуждение, что лишний `div` ничего не значит и он может быть вставлен, лишь что бы ублажить магию разметки. Но в действительности любой DOM элемент - это атомарная часть веб-страницы - которая, в любом, случае несет какую-то полезную нагрузку. Элемент может быть простым `Container` и это никак не принижает его пользу. При этом он точно будет иметь какие-то стили (как минимум по умолчанию), ради которых он и используется.

Вот уже второй десяток лет мы привыкли что DOM элементы - это про одно, а стили про другое, но так ли это? На самом деле одно не может существовать без другого. Даже на странице с полным отсутствием стилей у элементов они присутствуют по умолчанию (что-то можно увидеть в shadow-DOM). Вам не кажется странным классическое написание `<button class="btn"...`? Зачем иметь две сущности: элемент `button` и набор стилей в классе `.btn` - если они могут существовать только вместе? При этом для управления состоянием (атрибутов и стилей) кнопки мы используем третью сущность в виде каких-то обработчиков на JS. Разве это не странно?

**styled components** - переводится, дословно, как "стилизованные компоненты". Каждый такой компонент - это атомарный элемент нашего приложения, который абстрагирует и совмещает в себе всю необходимую логику и описание компонента: тип DOM элемента, набор стилей и их зависимость от аргументов (props).

В классическом SASS вы пишите стили отдельно от основного компонента, да. Но управляете ими в используемом компоненте! Т.е. вы скорее всего нативно или с помощью _classnames_ управляете поведением отображения компонента, подставляя те или иные классы в зависимости от аргументов и делаете это внутри компонента, который, казалось бы, должен отвечать за другую абстракцию - обычно это комбинирование и вывод компонентов для рендера. Не _CSS in JS_ решения не позволяют элегантно управлять стилями динамически в рантайме, на странице пользователя. Для этого необходимо либо описывать дополнительный контейнер управления для элемента, либо делать это в родительском компоненте. В обоих случаях можно увидеть лишний шаблонный код. SC предлагает избавится от этого, давая инструмент описания компонента представления в единой абстракции:

```javascript
const Button = styled.button`
  border-radius: 0.2rem;
  border-color: ${p => (p.disabled ? 'gray' : 'black')};
`;
```

В примере выше каждый наш инструмент (DOM, CSS, JS) используется строго в по своему назначению, не имея зависимости друг с другом.

 <!--

## Подробнее в следующих главах

Все вышесказанное - только подспорье, на практике _CSS in JS_ и **SC** в частности предоставляют великолепный функционал выраженный удобными инструментами (API) для приятной ([DX](https://www.google.com/search?q=developer+experience&oq=developer+experience&sourceid=chrome&ie=UTF-8)) и эффективной реализации компонентного (модульного) подхода, а так же: динамические стили от аргументов, темы, шаблоны, расширение / перезапись базовых компонентов / стилей.

# Про CSS in JS

* Достаточно просто сказать про Гудини - будущее за CSS in JS - и это по спеке!
    CSS parser API - возможность писать парсеры для CSS на JS (типо бабеля)
    CSS Typed OM - производительная работа с css значениями из JS
    ...

* Динамические стили невозможны с Sass и LESS (динамические классы о другом)
* Исключение коллизии имен (классов)
* Нет проблем со сборкой
* [DX]

# Примеры использования

* самое сочное из API
* сопосотавление с Sass

# Гайдлайн

* [atomic design]
* темы
* селекторы

### Вопросы
* Скорость работы на клиенте
* SSR
* Тришейкинг

> Решили, в свое время, для SC теги через `data-` указывать

https://gist.github.com/artalar/c8695ce2c008a269ff79d7c5a611b0d0ы

-->
