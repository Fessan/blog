<!--

# Заметки

### Pointer Events vs Touch Events
_Touch Events_ описывают работу с тачем. Появились в 2009 в WebKit, в 2011 спецификация на согласовании была заблокирована, в 2013 принята. Каждое событие имеет в target блок с которого началось событие.

![caniuse Touch Events](http://s.csssr.ru/U8SMMLH99/2018.08.21-11:00:39.png)

_Pointer Events_ описывают работу с "прикосновения" (мышь, тач, перо), похожи по API Mouse Events . Появились в 2012, приняты в 2015. Каждое событие имеет в target блок над которым указатель в момент события, методом `.setPointerCapture(e.pointerId)` можно зафиксировать элемент для текущего движения(?). Свойства евента: MouseEvent + pointerType, isPrimary, width, height (ширина и высота контакта), pressure (сила давления), tiltX, tiltY (углы наклона). Так же в CSS есть `touch-action: auto | none | pan-x | pan-y | manipulation`

![caniuse Pointer Events](http://s.csssr.ru/U8SMMLH99/2018.08.21-11:12:59.png)

## Mouse

- менять иконку мышки

# _

Изначально DnD реализовывался через клонирование элемента и движение (и захват) его по mouse событиям

События:
- dragstart - при старте драга
- drag
- dragenter - при попадании мыши на таргет
- dragleave - при ухода мыши с таргета
- dragover - при каждом движении над объектом
- drop
- dragend

Атрибут this/e.target отличается для каждого типа событий и зависит от места в модели событий перетаскивания.

В некоторых браузерах при перетягивании файлов в окно браузера они автоматически открываются, что бы такого не произошло нам нужно отменить стандартное поведение браузера. `event.preventDefault();`

Для touch можно использовать метод document.elementFromPoint, который позволяет получить ссылку на элемент по координатам.

Следует отметить, что в большинстве браузеров перетаскивание выделенных фрагментов текста, изображений и элементов привязок с атрибутом href (src?)поддерживается по умолчанию. Его можно перенести в адресную строку, элемент <input type="file" /> и даже на рабочий стол.

Селектор `[draggable]`?

Другие (в частности FF) в ходе операции перетаскивания требуют [отправки данных](https://www.html5rocks.com/ru/tutorials/dnd/basics/#toc-dataTransfer)

Mozilla и Firefox поддерживают ряд возможностей, которые выходят за рамку стандартной модели спецификации. Они позволяют пользователю перемещать несколько элементов и перемещать нестроковые данные. Для детальной информации смотрите [Dragging and Dropping Multiple Items](https://developer.mozilla.org/en-US/docs/DragDrop/Dragging_and_Dropping_Multiple_Items).

Помните о том, что не все элементы могут быть целью (например, изображения).

Запомните, что только drag-события срабатывают на протяжении операции перемещения; события мыши, такие как mousemove - нет. Также запомните, что события dragstart и dragend не срабатывают при попытке перенести файл из операционной системы в браузер.

> Перекрытие фантомным элементом может остановить DnD, если новый элемент окажется под мышью

### Материалы по теме

- Учебник на русском https://learn.javascript.ru/drag-and-drop
- Спека - https://html.spec.whatwg.org/multipage/dnd.html#dnd
- **Подробное введение** - https://www.html5rocks.com/ru/tutorials/dnd/basics
- Пример - https://habr.com/post/125424/
- UX - https://habr.com/post/216737/
- Сортировка без jQuery - https://habr.com/company/mailru/blog/207048/
- Видео доклада "Pointer Events vs Touch Events" https://www.youtube.com/watch?v=4o9joROJVHg

 -->

# План

## История и возможности Drag and Drop в Web

> ## **урок 1.** _Вводный теоретический урок (без кодинга) для знакомства с DnD в общем и в вебе в частности_

### Что такое Drag and Drop

**_Drag and Drop_** - _Drag'n'Drop_ - _DnD_ - дословно "потяни и положи" - это паттерн пользовательского опыта (UX) для взаимодействия с визуальным интерфейсом, с помощью которого пользователь может быстрее и, главное, нагляднее выполнить какую-то комплексную операцию, с помощью "перетягивания" [мышкой] на экране смыслового блока в другой смысловой контекст .

Например, если пользователь работает с несколькими списками и ему нужно переместить элемент из одного списка в другой, как бы он мог это сделать в "обычном" интерфейсе? Ему нужно совершить целый ряд точечных действий: 1) вызвать меню элемента, 2) выбрать опцию переноса в другой список, 3) выбрать необходимый список. При этом каждый пункт - это своя микрозадача со своим микроконтекстом: необходимо найти нужную кнопку из перечня всех, необходимо добраться до нее мышью или клавиатурой что бы выбрать и так сделать трижды, согласно нашему примеру. Все это прибавляет ментальный вес и увеличивает дискомфорт пользователя.

Как же можно упростить взаимодействие? В обычной жизни мы бы просто взяли рукой предмет из одного ящика и переложили бы в другой, а можно ли что-то подобное сделать через экран? DnD предлагает нам использовать мышь как руку в реальном мире: взять ей что-то и перетащить куда нужно - ментально эта операция воспринимается намного проще.

![](../assets/2018-09-10-08-47-47.png)

В действительности, хоть DnD и проще для пользователя, но его техническая реализация совсем не простая, особенно до введения стандарта HTML5

### DnD до HTML5

Фундаментально пользователю для перетаскивания нужно не много: 1) зажать кнопку мыши над блоком, 2) переместить мышку, 3) отпустить кнопку. Но каждый из этих пунктов на техническом уровне сопровождается целым рядом особенностей, в частности: как определять перетаскиваемый элемент, как плавно изменять его положение, как определять куда его можно "бросить", а куда нет - все это осложняется, порой, комплексной структурой DOM элементов и [слишком] гибкой системой событий.

А что если пользователь хочет перетянуть элемент не мышкой, может быть у него сенсорный экран телефона или стилус?

#### История API: Mouse Events, Touch Events, Pointer Events

Сейчас доля сенсорных устройств, в частности смартфонов и планшетов, быстро увеличивается и захватывает web. Но изначальная спецификация для работы с указателем - мышкой, это не предполагала.

В 2009 году, вслед за айфоном, в движке WebKit появилась спецификация Touch Events, которая описывала интерфейс для работы с событиями от прикосновения к экрану и сильно отличалась от спецификации Mouse Events. Долгое время эта спецификация подвергалась критике и не принималась в стандарт, но в 2013 году, все же, была принята.

Но Touch Events описывали только взаимодействие пальцем с экраном, при этом как-то нужно было обрабатывать стилус: силу и угол его нажатия. Так же в MakBook последних поколений появилась возможность регестрировать силу нажатия на тачпад, что то же было бы интересно использовать в веб-приложениях.

Спецификация Pointer Events, появившееся в 2012 году и принятая в 2015 предполагает включать в себя все возможные взаимодействия с интерфейсом, включая и новые углы и силу наклона, и, возможно, какие-то будущие особенности. Интерфейс и API Pointer Events наследуются от Mouse Events, поэтому удобны в работе.

Одним из ключевых различий Pointer Events от Touch Events, помимо ограниченного API последнего, является то что каждое pointer событие имеет в target блок над которым указатель в момент события, а каждое событие touch имеет в target блок с которого началось событие - что менее удобно, если нужно соотнести целевой элемент и текущее положение указателя.

В общем и целом рекомендуется использовать Pointer Events с полифилами для Safari

#### Механика Mouse Events

<!-- TODO: вынести в отдельный урок? -->
<!-- TODO: сделать слайды с разбором (примером) по каждому пункту -->

-> **Event**

- _target_ - ссылка на элемент где произошло событие
- _currentTarget_ - ссылка на элемент где перехвачено событие

-> **UIEvent**

-> **MouseEvent**

- _clientX_ - координата указателя на экране по горизонтали
- _clientY_ - координата указателя на экране по вертикали
- _pageX_ - координата указателя в документе по горизонтали
- _pageY_ - координата указателя в документе по вертикали
- _offsetX_ - координата указателя от верхнего левого края _target_ по горизонтали
- _offsetY_ - координата указателя от верхнего левого края _target_ по вертикали
- _movementX_ - разница в координатах с предыдущим положением мыши по горизонтали (при событии mousemove)
- _movementY_ - разница в координатах с предыдущим положением мыши по вертикали (при событии mousemove)
- _relatedTarget_ - опциональная ссылка на зависимый эелемент (для mouseover/out/enter/leave)
- _which_ - тип кнопки
  - _0_ - No button
  - _1_ - Left button
  - _2_ - Middle button (if present)
  - _3_ - Right button
- _shiftKey_, _altKey_, _ctrlKey_, _metaKey_ - определяют нажата ли соответствующая клавиша

->

- **mousedown** - кнопка мыши нажата над элементом
- **mouseup** - кнопка мыши отпущена над элементом
- **mousemove** - движение мыши над элементом
  > в целях производительности событие происходит не попиксельно (но "часто"). Какие-то обработчики могут не поймать движение мыши над собой, если она двигалась над ними очень быстро
- **mouseover** - мышь появилась над видимой части элемента (которую ничто не перекрывает)
  > логика срабатывания как у **mousemove**
- **mouseout** - мышь ушла с видимой части элемента (за пределы элемента или на его перекрытие)
- **mouseenter** - мышь появилась в координатной сетки элемента
  <!-- TODO: проверить при перекрытии блока не дочерним элементом -->
  > не всплывает, логика срабатывания как у **mousemove**
- **mouseleave** - мышь ушла из координатной сетки элемента
  > не всплывает
- **click**
  - **mousedown** + **mouseup**
  - _which_ === _1_
- **contextmenu**
  - **mousedown** + **mouseup**
  - _which_ === _3_
- **dblclick**
  - **click** + **click**
    > поведение по умолчанию - выделение

### DnD в HTML5

<!--
- https://developer.mozilla.org/ru/docs/Web/Guide/HTML/Drag_and_drop
- https://developer.mozilla.org/en-US/docs/Web/API/HTML_Drag_and_Drop_API/Drag_operations
- https://developer.mozilla.org/en-US/docs/Web/API/HTML_Drag_and_Drop_API/Recommended_drag_types
- https://html.spec.whatwg.org/multipage/dnd.html#dnd
- https://www.html5rocks.com/ru/tutorials/dnd/basics/
- https://codesandbox.io/s/mqz3wxkjqj
 -->

В стандарте HTML5 появилась спецификация для нативной работы с перетаскиванием блоков-элементов, текста и, даже, файлов из других окон ОС. Все это реализуется через новые события - Drag Event. Это особый тип события который вызывается на элементе при его участии в перетаскивании

#### Свойства Drag Event
- Drag Data:
    - все drag-события имеют свойство `dataTransfer` конструктора [DataTransfer](https://developer.mozilla.org/en-US/docs/Web/API/DataTransfer) в котором должны быть описаны перемещаемые данные и их [тип](https://developer.mozilla.org/en-US/docs/Web/API/HTML_Drag_and_Drop_API/Recommended_drag_types) (формат): `event.dataTransfer.setData("text/plain", "Text to drag");`. Это удобно в случае если есть несколько отличающихся целей для драга или цель специфичная для определенного типа - например, область для загрузки файлов (в нее нельзя перетянуть выделенный текст, т.е. эта область не должна реагировать на его перемещение)
    - `setData` можно вызвать несколько раз и для разных типов будут сохранены разные значения (key-value storage)
    - Метод `event.dataTransfer.clearData` принимает конкретный тип и удаляет его, если тип не передан - удаляются все типы.
    - при перетаскивании ссылок или картинок в dataTransfer по умолчанию помещается их ссылка, при перемещении выделения - его текст.
- Drag Feedback Image
    - При перетаскивании элемента браузер по умолчанию генерирует изображение из этого элемента: оно всегда полупрозрачное, а при большом<!-- TODO: каком? ---> размере отображается только ближе к курсору (скругленная сильная полупрозрачность по краям)<!-- TODO: не смог воспроизвести, но было же? --->
    - При событии `dragstart` у свойства `dataTransfer` можно использовать метод `setDragImage`, с помощью которого устанавливается собственное изображение перетаскиваемого элемента. Это может быть ссылка на любой элемент (ему, даже, не необходимо быть в DOM), но предпочтительнее использовать Image<!-- TODO: SVG? --->, пример: `dataTransfer.setDragImage(img, xOffset, yOffset);` (второй и третий аргумент - сдвиг относительно мыши).
    > **при этом в не зависимости от стилей элемента - он все равно будет полупрозрачный!**
- Drag Effects
- Drop Targets
- Mozilla и Firefox поддерживают [Dragging and Dropping Multiple Items](https://developer.mozilla.org/en-US/docs/DragDrop/Dragging_and_Dropping_Multiple_Items)

#### Новые события

В новом стандарте по умолчанию ссылки, картинки и выделенный текст являются перетаскиваемыми, что бы это отключить необходимо элементу добавить атрибут `draggable="false"`. Для всех остальных блоков, что бы сделать их перетаскиваемыми необходимо соблюсти 3 условия:
- Установить элементу атрибут `draggable="true"`
- Установить обработчик событий для `dragstart`
    > обработчик может быть установлен выше, т.к. `dragstart` всплывает
- Установить drag data в обработчике `dragstart`:
    ```html
        <div
            draggable="true"
            ondragstart="event.dataTransfer.setData('text/plain', 'Мета-данные')"
        >
            Этот текст можно перетащить, но нельзя выделить
        </div>
    ```


Разберем новые события для управления перетаскиванием

- **dragstart** - событие срабатывает на перетаскиваемом элементе при начале перетягивания. Срабатывает _только_ на элементе, т.е. не срабатывает при DnD из ОС, другой вкладки и т.п.
  <!-- TODO: надо бы попробовать передать в Drag Data что-нибудь из одной страницы в другую -->
- **dragenter** - событие срабатывает на целевом элементе, когда на него попадает перемещаемый элемент
- **dragover** - обытие срабатывает на целевом элементе каждые несколько сотен милисекунд, когда перемещаемый элемент передвигается над целевым
- **dragleave** - событие срабатывает на целевом элементе в момент перетаскивания, когда курсор мыши выходит за пределы элемента
- **drag** - событие срабатывает при перемещении <!-- TODO: -->**???**
- **drop** - событие срабатывает на целевом элементе при отпускании элемента над целью перетягивания. Событие не сработает, если пользователь отменит перетаскивание, например, нажав Escape <!-- TODO: что еще кроме ecs может быть? -->
- **dragend** - событие срабатывает на перетаскиваемом элементе после окончания перетаскивания (и при "попадании" в цель и при отмене перетаскивания) <!-- TODO: что пеервое срабатывает: drop или dragend -->

> #### Заметки
> - когда происходит перетаскивание Mouse события не срабатывают.
> - когда элемент `draggable="true"` в нем невозможно выделить текст, для того что бы обойти это можно зажать `alt` - это поведение по умолчанию в браузерах

#### Перетаскивание из других окон ОС

Текст

#### 

> #### Заметки
> - Если вы хотите использовать для DnD именно HTML5 имплементацию, но при этом вам необходимо поддерживать устаревшие версии браузеров можно посмотреть на необходимые флаги и трюки в [этой статье](https://www.html5rocks.com/ru/tutorials/dnd/basics/).

## Примеры решения задач на HTML5 DnD

> ## **урок 2.** _Кодинг_

### Детальнее об API и его использовании

### Перемещиение картин в галереи между альбомами

#### Пример с кодом

### Что нельзя сделать c HTML5 DnD

> Прозрачность для больших блоков

> Анимации движения

> Кастомизации положения: только вертикальное или только горизонтальное перетаскивание (слайдеры)

## Полный контроль DnD

> ## **урок 3.** _Кодинг_

> вступление `ahead to the past`

### Движение

> Рисуем комету

> перетаскиванием через Mouse Event

#### left + top vs копирование vs transform

#### Один обработчик для нескольких элементов

> onmouseenter onmouseleave

#### Анимации

> Хвост кометы

## react-dnd

> ## **урок 4.** _Знакомство с концепциями_

#### Влияние redux

#### Обзор API

## Пример на react-dnd

> ## **урок 5.** _Кодинг_
>
> может быть разделить на 2 урока...

### Переписываем галерею

> DropTarget

### Переписываем комету

> DragLayer
